<<div class='leftcol'|<<leftcoldoc version="dev">>>>
      <<div class="colprincipale"|
        ==4. Using Eliom client side
     
//Warning: Features presented here are experimental.
We have been working on them for more than two years and
they will be released very soon.
Use it if you want to test,
but syntax and interfaces will change a lot during the next weeks,
as we are currently working on simplifying the syntax and
uniformizing server and client sides.//

//The manual is very basic for now. 
Turn back in a few days for a more complete manual!//
   
This part of the manuel describes how to use Eliom for mixing client side
and server side programming.
Eliom allows to write the client and server parts of a Web application
fully in Objectice Caml.
For now it is using O'Browser to run OCaml programs in the browser.
But Eliom will probably be available for other platforms soon.


===@@id="p4basics"@@
        
====Your first client-server application
        <<div class="onecol"|

First, I need to create my Eliom application, by applying the functor
{{{Eliom_predefmod.Eliom_appl}}}. You can define here what will be
the default title for pages belonging to this application, the
default container for pages, the default stylesheets you want for your
whole application.
          
<<code language="ocaml" |
(****** open on both side *******)
open XHTML.M
(****** server only *******)
open.server Eliom_parameters
open.server Eliom_predefmod.Xhtmlcompact
open.server Eliom_services

(* for client side only : open.client *)

module.server Eliom_appl =
  Eliom_predefmod.Eliom_appl (
    struct
      let.server client_name = "tutoeliom_ocsigen2_client"
      let.server default_params =
        {Eliom_predefmod.default_appl_params with
           Eliom_predefmod.ap_title = "Eliom application example";
           Eliom_predefmod.ap_headers = 
            [XHTML.M.style ~contenttype:"text/css"
               [XHTML.M.pcdata ".clickable {color: #111188; cursor: pointer;}"]]
        }
    end)
>> Now I can define my first service belonging to that application: <<code language="ocaml" |

let.server eliomobrowser1 =
  Eliom_appl.register_new_service
    ~path:["eliomobrowser1"]
    ~get_params:unit
    (fun sp () () ->
      Lwt.return
        [p ~a:[a_onclick 
                 ((fun.client (() : unit) -> Js.alert "clicked!") ())]
           [pcdata "I am a clickable paragraph"];
         
        ])
>>
All services belonging to the application will be entry points to the 
application. It means that if you call such a service, the client side
code will be sent to the browser, and the client side execution will
start, //and will not stop if you go to another service belonging to
the same application!//

====Compiling
//soon (have a look at Ocsigen source for now -- //examples// directory)// 

====Using a distant Eliom service in client side code

The code will look like:
<<code language="ocaml"|
p ~onclick:{{Eliom_obrowser.post_request ~sp ~service:myblockservice ()
                   ~>>= Node.append bodynode}}
        [pcdata "Click here to add content from the server."];
>>

For now, the syntax extension has not been implemented, thus the syntax
is somewhat more complicated. Here are some examples of what you can do:
<<code language="ocaml" |
let.server eliomobrowser2 = new_service ~path:["eliomobrowser2"] ~get_params:unit ()

let.server myblockservice =
  Eliom_predefmod.Blocks.register_new_post_coservice
    ~fallback:eliomobrowser2
    ~post_params:unit
    (fun _ () () -> 
       Lwt.return
         [p [pcdata ("I come from a distant service! Here is a random value: "^
                       string_of_int (Random.int 100))]])

let item () = li [pcdata Sys.ocaml_version]

let.server _ =
  Eliom_appl.register
    eliomobrowser2
    (fun sp () () ->
      Lwt.return
        [
>>
  The following example shows how to go to another service,
  exactly like pressing a link (here a service that do not belong to
  the application):
<<code language="ocaml" |
          p 
            ~a:[
              a_onclick 
                ((fun.client
                    (sp : Eliom_client_types.server_params)
                    (service : (unit, unit, 'c, 'd, 'e, 'f, 'g, Eliom_services.http) Eliom_services.service) -> 
                      Eliom_client.exit_to ~sp ~service () ()
                 ) (Eliom_obrowser.client_sp sp) Tutoeliom.coucou)
            ]
            [pcdata "Click here to go to another page."];
          
>>
  The following examples shows how to do a request to a service,
  and use the content:
<<code language="ocaml" |
          p 
            ~a:[
              a_onclick 
                ((fun.client
                    (sp : Eliom_client_types.server_params)
                    (myblockservice : (unit, unit, 'c, 'd, 'e, 'f, 'g, Eliom_services.http) Eliom_services.service) -> 
                      let body = JSOO.eval "document.body" in
                      (*Js.get_element_by_id "bodyid"*)
                      Eliom_client.call_service
                        ~sp ~service:myblockservice () () ~>>= fun s ->
                          (try
                             let l = Js.Node.children (Js.dom_of_xml s) in
                             List.iter (Js.Node.append body) l
                           with e -> Js.alert (Printexc.to_string e));
                          Lwt.return ()
                 ) (Eliom_obrowser.client_sp sp) myblockservice)
            ]
            [pcdata "Click here to add content from the server."];
             
>>
  The following examples shows how to change the URL.
  This is a low level function and is usually not to be used directly.
  As browsers do not not allow to change the URL,
  we write the new URL in the fragment part of the URL.
  A script must do the redirection if there is something in the fragment
  while the page is loading.
<<code language="ocaml" |
          p 
            ~a:[
              a_onclick 
                ((fun.client
                    (sp : Eliom_client_types.server_params)
                    (service : (unit, unit, 'c, 'd, 'e, 'f, 'g, 'ret) Eliom_services.service) ->
                      Eliom_client.change_url ~sp ~service () ()
                 ) (Eliom_obrowser.client_sp sp) Tutoeliom.coucou)
            ]
            [pcdata "Click here to change the URL."];
          
>>
  The following examples shows how to change the current page,
  without stopping the client side program.
<<code language="ocaml" |
          p 
            ~a:[
              a_onclick 
                ((fun.client
                    (sp : Eliom_client_types.server_params)
                    (service : (unit, unit, 'c, 'd, 'e, 'f, 'g, Eliom_services.appl_service) Eliom_services.service) -> 
                      Eliom_client.change_page ~sp ~service () ()
                 ) (Eliom_obrowser.client_sp sp) eliomobrowser1)
            ]
            [pcdata "Click here to change the page without stopping the program."];

             
>>
====Refering to parts of the page in client side code
<<code language="ocaml" |

          (let container = ul (item ()) [ item () ; item ()] in
           div [p ~a:[a_onclick 
                       ((fun.client (container : node) ->
                           let nl = XHTML.M.toelt (item ()) in
                           Js.Node.append container nl) container)]
                 [pcdata "Click here to add an item below with the current version of OCaml."];
                container]);
          
>>
====Refering to server side data in client side code
  In the case you want to send some server side value with your page,
  just do:
<<code language="ocaml" |

          let my_int = 123456789 in
          p ~a:[a_onclick 
            ((fun.client (my_int : int Eliom_client_types.data_key) ->
                Js.alert (string_of_int (Eliom_obrowser_client.unwrap my_int))) 
               (Eliom_obrowser.wrap ~sp my_int))]
            [pcdata "Click here to see a server side value sent with the page."];
          
        ])
>>
====Using OCaml values as service parameters
It is now possible to send OCaml values to services.
To do that, use the {{{Eliom_parameters.caml}}} function:
<<code language="ocaml" |
let.server eliomobrowser3' =
  Eliom_appl.register_new_post_coservice'
    ~post_params:(caml "isb")
    (fun sp () (i, s, l) ->
      Lwt.return
        [p (pcdata (Printf.sprintf "i = %d, s = %s" i s)::
              List.map (fun a -> pcdata a) l
           )])



let.server eliomobrowser3 =
  Eliom_appl.register_new_service
    ~path:["eliomobrowser3"]
    ~get_params:unit
    (fun sp () () ->
      Lwt.return
        [p ~a:[a_onclick 
                 ((fun.client
                    (sp : Eliom_client_types.server_params)
                    (service : (unit, (int * string * string list), 'c, 'd, 'e, 'f, 'g, Eliom_services.appl_service) Eliom_services.service) -> 
                      Eliom_client.change_page ~sp ~service
                       () (22, "oo", ["a";"b";"c"]))
                    (Eliom_obrowser.client_sp sp) eliomobrowser3')]
           [pcdata "Click to send Ocaml data"]
        ])
>>
====Sending OCaml values using services
It is possible to do services that send any caml value. For example:
<<code language="ocaml" |
let.server eliomobrowser4' =
  Eliom_predefmod.Caml.register_new_post_coservice'
    ~post_params:unit
    (fun sp () () -> Lwt.return [1; 2; 3])

let.server eliomobrowser4 =
  Eliom_appl.register_new_service
    ~path:["eliomobrowser4"]
    ~get_params:unit
    (fun sp () () ->
      Lwt.return
        [p ~a:[a_onclick 
                 ((fun.client
                    (sp : Eliom_client_types.server_params)
                    (service : (unit, unit, 'c, 'd, 'e, 'f, 'g, int list Eliom_parameters.caml) Eliom_services.service) -> 
                      let body = JSOO.eval "document.body" in
                      Eliom_client.call_caml_service ~sp ~service () ()
                      ~>>= fun l ->
                      List.iter 
                        (fun i -> Js.Node.append body 
                           (Js.Node.text (string_of_int i)))
                        l;
                      Lwt.return ()
                  )
                    (Eliom_obrowser.client_sp sp) eliomobrowser4')]
           [pcdata "Click to receive Ocaml data"]
        ])
>>
====Implicit registration of services to implement distant function calls
<<code language="ocaml" |
>>
<<code language="ocaml" |
>>
<<code language="ocaml" |
>>
        >> <<|onecol~>>
      >> <<|colprincipale~>>
<<code language="ocaml" |
>>
