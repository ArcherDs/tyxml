=Implementing Web interaction using Eliom=

<<div class="wip"|**Work in progress**>>

This chapter is a tutorial explaining how to write a small Web site
with several pages, users, sessions, etc. Then, to show that we can
mix this kind of interaction with client side programs, we will add
the features of this site to the program of the previous chapter.

We suppose you have read at least the first section of the previous
chapter, explaining how to create a service and constuct valid HTML pages.

First, we will create a simple Web site with one main page and one
page for each user (supposing we have several users already created).
Then we will add a connection form.
<<span class="wip"|We will also ... //(dynamic services)//>>

Then we will mix this site with the application of the previous chapter,
add a music player.

As an extension, we will see how to connect with external account using OpenID,
and add an Atom stream to our WebSite.

==Services==
<<span class="wip"|titre>>
===The main page===
Let's start again from scratch with the following site.
<<code language="ocaml"|open XHTML5.M

let main_service =
  Eliom_output.Xhtml5.register_service
    ~path:[""] ~get_params:Eliom_parameters.unit
    (fun () () ->
      Lwt.return
        (html (head (title (pcdata "")) [])
                       (body [h1 [pcdata "Hello"]])))
>>
Note that we are using {{{Eliom_output.Xhtml5}}} as we do not
need a client side program for now.

Put this example in a file ({{{tuto.ml}}}), compile it:
{{{
ocamlfind ocamlc -thread -package ocsigen -c tuto.ml
}}}

Then adapt your configuration file as explaining in previous chapter
to load the file {{{tuto.cmo}}}.
Then run this site.

===Adding a page for each user===
<<div class="concepts"|Services with parameters\\
Using parts of the path as parameters>>
We will now create a page for each user.
We create a new service, taking the user name as parameter:
<<code language="ocaml"|let user_service =
  Eliom_output.Xhtml5.register_service
    ~path:[""] ~get_params:(Eliom_parameters.string "name")
    (fun name () ->
      Lwt.return
        (html (head (title (pcdata name)) [])
                       (body [h1 [pcdata name]])))
>>

Add these lines in the same file, compile,
run the server and try for example {{{http://localhost:8080/?name=toto}}}.

<<div class="encadre"|====Paths====
Note that we are using the same path as for the first service.
Eliom will automatically call the right service according to the
parameters given in the request.
>>
<<div class="encadre"|====Services with parameters====
To define a service taking parameters in the URL (GET parameters),
just add a description of the parameters you want in the {{{~get_params}}}
argument of the {{{register_service}}} function. In the example, the service
is expecting a parameter called {{{name}}} of type string.

The handler function (function implementing the service) always takes
two parameters:
* The first one corresponds to GET parameters (here a string).
* The second one corresponds to parameters that are sent in the body of the
HTTP request (POST parameters). We will see soon how to make services wiht
POST parameters.

The module
<<ocsigendoc version="dev" file="Eliom_parameters.html"|<<span class="code"|Eliom_parameters>>>>
defines many parameter types. For example if you write :
{{{
~get_params:(Eliom_parameters.int "i")
}}}
Eliom will try to find a parameter called {{{i}}}
and to translate it into an {{{int}}}.
In that case, the handler function take an {{{int}}} as second parameter.

If you want several parameters, you can do for example:
{{{
~get_params:(int "i" ** string "s")
}}}
after opening the {{{Eliom_parameters}}} module.
In that case, the handler function takes a pair of type {{{(int * string)}}}.

//Warning:// The operator {{{**}}} is an infix //binary// operator.
It will always create pairs, and not triples or other tuples.

The module
<<ocsigendoc version="dev" file="Eliom_parameters.html"|<<span class="code"|Eliom_parameters>>>>
also defines other parameter types: for example floats, 64 bits integers,
sum types, but also more complex types, like sets or lists of values.
It is also possible to define your own parameter types.
>>

For our program, we would prefer to take one part of the path as parameter
for the name of the user.
I change the definition of my service this way:
<<code language="ocaml"|let user_service =
  Eliom_output.Xhtml5.register_service
    ~path:["users"] ~get_params:(Eliom_parameters.suffix (Eliom_parameters.string "name"))
    (fun name () -> ... )
>>

The user pages are now available at URLs
<<span class="code"|~http:~//localhost:8080/users~///username//>>.

<<div class="encadre"|====Using parts of the path as page parameters====
The module
<<ocsigendoc version="dev" file="Eliom_parameters.html"|<<span class="code"|Eliom_parameters>>>>
makes possible to use parts of the path as service (GET) parameters.

In addition to
 <<ocsigendoc version="dev" file="Eliom_parameters.html" fragment="VALsuffix"|<<span class="code"|Eliom_parameters.suffix>>>>,
there are also many other values to specify that you want for example
the full suffix as a string, as a list of string, or if you want to mix
suffix parameters with usual GET parameters. You can also take as parameters
parts of the path that are not a suffix of the path
(using
 <<ocsigendoc version="dev" file="Eliom_parameters.html" fragment="VALconst"|<<span class="code"|Eliom_parameters.const>>>>).
<<span class="wip"|See **here** for more information on suffixes>>.

//Warning:// Even if it is not displayed in the URL, suffix parameters
have a parameter name. This allows to make forms towards that kind of services.
Actually each "suffix service" has an equivalent without suffix
(which is by default automatically redirected towards the suffix version).
>>


===Links===
<<div class="concepts"|Links\\Database libraries>>

We now want to add a link on each user page to go back to the main page.

Change the handler of {{{user_service}}} into:
<<code language="ocaml"|    (fun name () ->
      Lwt.return
        (html (head (title (pcdata name)) [])
                       (body [h1 [pcdata name];
                       p [Eliom_output.Xhtml5.a ~service:main_service [pcdata "Home"] ()]])))
>>

<<div class="encadre"|==== Creating hyperlinks ====
To create a link, one could use the function {{{XHTML5.M.a}}}.
But this requires to know the text of the URL to put in the {{{href}}}
attribute. A better way to create hyperlinks is to use
<<ocsigendoc version="dev" file="Eliom_output.XHTML5FORMSSIG.html" fragment="VALa"|<<span class="code"|Eliom_output.Xhtml5.a>>>>
(or {{{My_appl.a}}} if you have a client side program and {{{My_appl}}}
is the module created by the functor <<ocsigendoc version="dev" file="Eliom_output.Eliom_appl.html"|<<span class="code"|Eliom_output.Eliom_appl>>>>
as in previous chapter).

Thus, you dan't have to know the precise URL of the service you want to go,
and if the URL changes, all links will remain valid!
Using this function has a wonderful consequence: //You will never have
broken links!//

The function 
<<ocsigendoc version="dev" file="Eliom_output.XHTML5FORMSSIG.html" fragment="VALa"|<<span class="code"|Eliom_output.Xhtml5.a>>>>
takes as parameter:
* the service
* the content of the link
* URL parameters to be given to the service

====Links towards services with parameters====
In our example above, the last parameter is {{{()}}} because the service
does not expect any parameter. If the service expect for example a pair
{{{(int * string)}}}, you must give a matching value as last parameter.
OCaml checks at compile time that the type of the parameters in a link
corresponds to those expected by the service! Also note that the names
of parameters are taken automatically from the service, making impossible
to put wrong names.
>>

To show an example of link with parameters, we will display the list of
user pages on the main page. Here is the new version of the full program:

<<code language="ocaml"|open XHTML5.M
open Eliom_parameters

let main_service = Eliom_services.service ~path:[""] ~get_params:unit ()

let user_service =
  Eliom_services.service
    ~path:["users"] ~get_params:(suffix (string "name")) ()

(* User names and passwords: *)
let users = ref [("Calvin", "123"); ("Hobbes", "456")]

let user_links () =
  ul (List.map (fun (name, _) -> li [Eliom_output.Xhtml5.a ~service:user_service [pcdata name] name]) !users)

let _ = 
  Eliom_output.Xhtml5.register
    ~service:main_service
    (fun () () ->
      Lwt.return
        (html (head (title (pcdata "")) [])
              (body [h1 [pcdata "Hello"];
                     user_links ()])));

  Eliom_output.Xhtml5.register
    ~service:user_service
    (fun name () ->
      Lwt.return
        (html (head (title (pcdata name)) [])
                       (body [h1 [pcdata name];
                              p [Eliom_output.Xhtml5.a ~service:main_service [pcdata "Home"] ()]])))
>>

<<div class="encadre"|====Mutually recursive services====
As my two services are mutually recursive (the first one contains links towards
the second one and vice versa), we split the {{{register_service}}} in two
steps:
* First we create all the services using
<<ocsigendoc version="dev" file="Eliom_services.html" fragment="VALservice"|<<span class="code"|Eliom_services.service>>>>
* Then we register the handlers using the {{{register}}} function from
  the right module.

The function {{{register_service}}} is just a shortcut for these two functions.
>>

<<div class="encadre"|====Database libraries====
We suppose we have a database module for finding user information.
We will write the database part on the application later in this tutorial.
You can use any OCaml database binding (for example
[[http://developer.berlios.de/projects/pgocaml/|PGOcaml]] to program
database queries). We will use our own database library called
[[wiki(25):|Macaque]], which implements typed requests using //comprehensions//.
(See * *)

//Just remember that your query functions must be cooperative fot Lwt!//
For example PGOcaml is now implemented in monadic way,
which makes it 100% compatible with Lwt. And so is Macaque.

If your database module is not Lwt-cooperative but if it is thread-safe
(for preemptive threads), you can use the
<<ocsigendoc version="dev" file="Lwt_preemptive.html" fragment="VALdetach"|<<span class="code"|Lwt_preemptive.detach>>>>
function to make the blocking function be executed by a separate
preemptive thread.
>>


==Sessions==
===Connection service===
<<div class="concepts"|Services with hidden (POST) parameters\\Fallback service>>

Now I want to add a connection form.
First, I will create a service for checking the name and password.
As I don't want the username and password to be shown in the
URL, I will use //hidden parameters// (or POST parameters).
I create a new service taking these parameters:
<<code language="ocaml"|let connection_service =
  Eliom_services.post_service
    ~fallback:main_service
    ~post_params:(string "name" ** string "password")
    ()
>>

<<div class="encadre"|====Hidden (POST) services====
Services using the POST HTTP method are created using the function
<<ocsigendoc version="dev" file="Eliom_services.html" fragment="VALpost_service"|<<span class="code"|Eliom_services.post_service>>>>.
As you can see, there is a major difference with the function
<<ocsigendoc version="dev" file="Eliom_services.html" fragment="VALservice"|<<span class="code"|Eliom_services.service>>>>:
{{{post_service}}} does not take a path as parameter, but a (GET) service
as //fallback//.

This means that for each POST service, you must first create a GET
service at the same path, that will answer if the user sets a bookmark
on the page and turns back later without POST parameters.
Thus you will not get 404 errors if POST parameters are missing.

If the fallback has GET parameters, your service will have both GET
and POST parameters. In that case, GET parameters will be in the URL
and POST parameters will probably come from a form. In HTML, it is not possible
to mix GET and POST parameters in the same form.
>>

<<div class="encadre"|====POST or GET?====
POST parameters are sent in the body of the HTTP request
(whereas GET parameters are sent in the URL).
It is important to understand that they have a very different semantics.

Remember:
* Use GET parameters when you want your page to be bookmarkable
* Use POST parameters when you do not want the page to be bookmarkable,
  because, for example, it performs a side effect on the server
  (connecting a user, add something in a database, perform a payment~ ...).

//Warning:// Even if POST parameters are not shown in the URL,
they are sent in plain text. If you want to transmit private data,
you must use HTTPS (see <<span class="wip"|???>>).
>>

Now you can register a handler on the new service:

<<code language="ocaml"|  Eliom_output.Xhtml5.register
    ~service:connection_service
    (fun () (name, password) ->
      let message =
        if check_pwd name password
        then "Hello "^name
        else "Wrong name or password"
      in
      Lwt.return
        (html (head (title (pcdata "")) [])
              (body [h1 [pcdata message];
                     user_links ()])));
>>
where {{{check_pwd}}} is defined by:
<<code language="ocaml"|let check_pwd name pwd = try List.assoc name !users = pwd with Not_found -> false>>

===Connection form===
<<div class="concepts"|Forms>>
For now, I will add the connection form only on the main page of the site.

Let's create a function for generating this form:

<<code language="ocaml"|let connection_box () =
  Eliom_output.Xhtml5.post_form ~service:connection_service
    (fun (name1, name2) ->
      [p [pcdata "login: ";
          Eliom_output.Xhtml5.string_input ~input_type:`Text ~name:name1 ();
          br ();
          pcdata "password: ";
          Eliom_output.Xhtml5.string_input ~input_type:`Password ~name:name2 ();
          br ();
          Eliom_output.Xhtml5.string_input ~input_type:`Submit ~value:"Connect" ()
         ]]) ()
>>

Add a call to this function in the handler of the main service
(for example juste before user links).
<<div class="encadre"|====Forms====
Form creation is very similar with link creation, using the functions
<<ocsigendoc version="dev" file="Eliom_output.XHTML5FORMSSIG.html" fragment="VALget_form"|<<span class="code"|Eliom_output.Xhtml5.get_form>>>> and
<<ocsigendoc version="dev" file="Eliom_output.XHTML5FORMSSIG.html" fragment="VALpost_form"|<<span class="code"|Eliom_output.Xhtml5.post_form>>>>.

The first parameter is the service,
the last parameter (only for {{{post_form}}})
is for GET parameters you want to sent in the URL,
if the fallback of your POST service takes GET parameters.

The only difference is how we write form content:
instead of simply giving the content as parameter to the {{{get_form}}}
or {{{post_form}}} functions, you give a function, that will create the
form from the names of the parameters the service is expecting.
Thus, yo don't need to remember the parameter names you choosed
while creating the service, and you can change them easily without having
to update every form in your application.

In the example, as the service is expecting a pair {{{(string * string)}}}.
The function given to {{{post_form}}} takes two parameters corresponding
to the names of each field.

<<ocsigendoc version="dev" file="Eliom_output.XHTML5FORMSSIG.html"|<<span class="code"|Eliom_output.Xhtml5>>>>
defines constructors for all possible form fields.
OCaml checks that the name you use matches the field.
For example it is not possible to use the names above with
<<ocsigendoc version="dev" file="Eliom_output.XHTML5FORMSSIG.html" fragment="VALint_input"|<<span class="code"|Eliom_output.Xhtml5.int_input>>>>
as it is a name for a string.
>>


===Opening a session===
<<div class="concepts"|Session data, Eliom references <<span class="new"|New in 1.90!>>>>

Now we want to remember that the user is connected.
Do do that we will set a reference when the user successfully connects,
and we will restrict the scope of this reference to the session
(that is, to the browser).

Add the following line at the beginning of your file:
<<code language="ocaml"|let (~>>=) = Lwt.bind>>

Define your Eliom reference with a default value:
<<code language="ocaml"|let username = Eliom_references.eref ~scope:`Session None
>>

Here is the new {{{connection_box}}} function:
<<code language="ocaml"|let connection_box () =
  Eliom_references.get username ~>>= fun u ->
  Lwt.return
    (match u with
      | Some s -> p [pcdata "You are connected as "; pcdata s]
      | None ->
        Eliom_output.Xhtml5.post_form ~service:connection_service
          (fun (name1, name2) ->
            [p [pcdata "login: ";
                Eliom_output.Xhtml5.string_input ~input_type:`Text ~name:name1 ();
                br ();
                pcdata "password: ";
                Eliom_output.Xhtml5.string_input ~input_type:`Password ~name:name2 ();
                br ();
                Eliom_output.Xhtml5.string_input ~input_type:`Submit ~value:"Connect" ()
               ]]) ())
>>

And replace the registration of the main service and the connection service by:
<<code language="ocaml"|  Eliom_output.Xhtml5.register
    ~service:main_service
    (fun () () ->
      connection_box () ~>>= fun cf ->
      Lwt.return
        (html (head (title (pcdata "")) [])
              (body [h1 [pcdata "Hello"];
                     cf;
                     user_links ()])));

  Eliom_output.Xhtml5.register
    ~service:connection_service
    (fun () (name, password) ->
      (if check_pwd name password
       then begin
         Eliom_references.set username (Some name) ~>>= fun () ->
         Lwt.return ("Hello "^name)
       end
       else Lwt.return "Wrong name or password")
      ~>>= fun message ->
      Lwt.return
        (html (head (title (pcdata "")) [])
              (body [h1 [pcdata message];
                     user_links ()])))
>>

<<div class="encadre"|==== More on Lwt ====
Function {{{Eliom_references.get}}} has type
{{{'a Eliom_references.eref -> 'a Lwt.t}}}.
The only way to use the result of such functions, that return values
in the //Lwt monad//, is to use {{{Lwt.bind}}}.
<<code language="ocaml"|Lwt.bind : 'a Lwt.t -> ('a -> 'b Lwt.t) -> 'b Lwt.t>>
It is convenient to define the infix operator {{{>>=}}} like this:
<<code language="ocaml"|let (~>>=) = Lwt.bind>>
Then the code
<<code language="ocaml"|f () ~>>= fun x -> >>
has to be read as
<<code language="ocaml"|let x = f () in>>
but for functions returning a value in the Lwt monad.

Note how the program indented. We strongly advise to use the same conventions.

There exists a syntax extension for Lwt, defining a new keyword
{{{lwt}}} that you can use instead of {{{let}}} for Lwt functions:
<<code language="ocaml"|lwt x = f () in>>

{{{Lwt.return}}} creates a terminated thread from a value
(without inserting a cooperation point):
<<code language="ocaml"|Lwt.return : 'a -> 'a Lwt.t>>
Use it when you must return something in the Lwt monad
(for example in a service handler, or often after a {{{Lwt.bind}}}).

=====Why Lwt?=====

An Eliom application is a cooperative program, as the server must be able
to handle several requests at the same time.
Ocsigen is using cooperative threading instead of the more widely used
preemptive threading paradigm. It means that no scheduler will interrupt your
functions where it wants. Switching from one thread to another is done
only when there is a //cooperation point//.

We will call //cooperative functions// all functions implemented in cooperative
way, that is: if something takes time to complete (for example reading a value
from a database), they insert a cooperation point to let other threads run.
Cooperative functions return a value in the Lwt monad.

In our example, the function {{{Eliom_state.get}}} may introduce a cooperation
point, because if your Eliom reference is persistent (see below), it is stored
in a database on the hard drive. That's why it returns a value in the Lwt monad.

Using cooperative threads has a huge advantage: as you know precisely where
cooperation points are, //you need very few mutexes// and you have //very
few risks of deadlocks//!

Using Lwt is very easy and does not cause troubles, provided you
never use //blocking functions// (non cooperative functions).
//Blocking functions will make the whole server get stuck!//
Remember:
* Use functions from module
{{{Lwt_unix}}} instead of module {{{Unix}}},
* Use cooperative database libraries (like PG'Ocaml for Lwt),
* If you want to use a non cooperative function, detach it in another
preemptive thread using
<<ocsigendoc version="dev" file="Lwt_preemptive.html" fragment="VALdetach"|<<span class="code"|Lwt_preemptive.detach>>>>,
* If you want to to a very long computation, insert manually
computations points using {{{Lwt.yield}}},
* {{{Lwt.bind}}} does not introduce any cooperation point.

>>

<<div class="encadre"|==== Eliom references ====

Eliom references are some kind of references with scope limited to
a session (by default), or to a client-side process
({{{~scope:`Client_process}}}), or to a "group of sessions"
(see later) ({{{~scope:`Session_group}}}), or to the current
request ({{{~scope:`Request}}}).

Define an Eliom reference with the function {{{Eliom_references.eref}}}
and precise the scope of this reference and the default value.
The function {{{Eliom_references.get}}} retrieve the value of this reference
for the current session (or client proces or group of sessions).
The default value is used for all sessions
(or client proces or group of sessions) for which is has not been
changed using {{{Eliom_references.set}}}.

By default, Eliom references are kept in memory and will disappear if
you shut down the server. But it is possible to create //persistence
Eliom references// that will survive after relaunching the server.
To do that, add the optional parameter {{{persistent}}} to the {{{eref}}}
function, with a string value corresponding to the name of the table
that will contain the values on hard disk.

<<div class="wip"|For now you need to rename this table every time you
change the type of your Eliom reference, otherwise the server will crash
(we are using OCaml's {{{Marshal}}} module).>>

It is not possible to create Eliom references containing functions
(closures).
>>

===Display the usual page after connection===
<<div class="concepts"|Actions>>

As you can see, our connection service is displaying a welcome page
which is different from the main page in connected mode.
We would rather display the same page.
One solution is to call the same handler after registering session data.

But a cleaner solution is to use an //action//.
Replace the registration of the connection service by:
<<code language="ocaml"|  Eliom_output.Action.register
    ~service:connection_service
    (fun () (name, password) ->
      if check_pwd name password
      then Eliom_references.set username (Some name)
      else Lwt.return ())
>>
Now the main page is displayed after connection.

<<div class="encadre"|==== Actions ====
An //action// is, a service that performs a side effect
and redisplays the current page.
The handler function returns {{{()}}}.
>>

===Putting a connection form on each page===
<<div class="concepts"|Non-attached coservices\\Redirections>>

<<div class="encadre"|==== Non-attached coservices ====
With many Web programming frameworks, adding a connection form on each page
of a site is complicated:
* A first solution is to do the same as we did for the main service
for all services (usually each page must check the presence of POST
parameters). This is clumsy.
* Another solution would be to create a special page on a separate path
to handle the registration, with some way to do a redirection to the page
we came from after connection. (Of course we want to stay on the same page
after sending the connection form!) This is ugly.

With Eliom, doing this is straightforward:
* For the connection service, we use a kind of service called
//non-attached coservice//, which means that it is not attached to
any path in particular. Calling this kind of service will not change
the //path// you see in the browser URL bar (just add parameters if
you use the GET method).
* Use an action to connect the user and
 redisplay the page corresponding to the current URL.

By default, a random identifier will be generated automatically by Eliom
for the non-attached coservice. If you want this identifier to be fixed,
you can specify it yourself while creating the service
using the {{{?name}}} optional parameter.
This identifier is added automatically by Eliom in each form (as
hidden field) and link.
>>

Transform the connection service into a non-attached coservice:
<<code language="ocaml"|let connection_service =
  Eliom_services.post_coservice'
    ~post_params:(string "name" ** string "password")
    ()
>>


Now you can add the connection box on user pages.
<<code language="ocaml"|let connection_service =
  Eliom_output.Xhtml5.register
    ~service:user_service
    (fun name () ->
      connection_box () ~>>= fun cf ->
      Lwt.return
        (html (head (title (pcdata name)) [])
                       (body [h1 [pcdata name];
                              cf;
                              p [Eliom_output.Xhtml5.a ~service:main_service [pcdata "Home"] ()]])));
>>

<<div class="encadre"|====Altenative: register a redirection====
Usually, after sending a POST form, it is good practice to do a redirection.
This avoids reposting the data if the user reloads the page.

Eliom provides the module
<<ocsigendoc version="dev" file="Eliom_output.Redirection.html"|<<span class="code"|Eliom_output.Redirection>>>>
to register services doing redirections.
Such services return a service without parameter.

Example:
<<code language="ocaml"|let redir_service = Eliom_output.Redirection.register_service
    ~path:["redir"]
    ~get_params:Eliom_parameters.unit
   (fun sp () () -> Lwt.return main_service)
>>

(If you want to give parameters to the service you return, use
<<ocsigendoc version="dev" file="Eliom_services.html" fragment="VALpreapply"|<<span class="code"|Eliom_services.preapply>>>> --- see <<span class="wip"|???>>.)

If you want to do a redirection towards the current page (that's our case),
use the special service 
<<ocsigendoc version="dev" file="Eliom_services.html" fragment="VALvoid_coservice'"|<<span class="code"|Eliom_services.void_coservice'>>>>, which is some kind
of POST non-attached coservice without parameter at all.
>>

<<div class="wip"| Relire cette section et la précédente>>

===Disconnection===

To create a disconnection form, we create another POST non-attached coservice,
and register another action.
We call the function
<<ocsigendoc version="dev" file="Eliom_sessions.html" fragment="VALclose_session"|<<span class="code"|Eliom_sessions.close_session>>>>
to remove all session data.

<<code language="ocaml"|let disconnection_service = Eliom_services.post_coservice' ~post_params:unit ()

let disconnect_box () =
  Eliom_output.Xhtml5.post_form disconnection_service
    (fun _ -> [p [Eliom_output.Xhtml5.string_input
                    ~input_type:`Submit ~value:"Log out" ()]]) ()

let _ =
  Eliom_output.Action.register
    ~service:disconnection_service
    (fun () () ->
      Eliom_sessions.close_session () ~>>= fun () ->
      Lwt.return ());
>>

Then add this form in the connection box:
<<code language="ocaml"|let connection_box () =
  Eliom_references.get username ~>>= fun u ->
  Lwt.return
    (match u with
      | Some s -> div [p [pcdata "You are connected as "; pcdata s; ];
                       disconnect_box () ]
      | None -> ...
>>

==Registration of users==
===Basic registration form===
<<div class="concepts"|Attached coservice>>
We will now add a registration form to the application.
We create a new regular service, attached to the path {{{/registration}}},
that displays a registration form, and an action that will add the user in
the "database":
<<code language="ocaml"|let new_user_form_service = Eliom_services.service ~path:["create account"] ~get_params:unit ()

let create_account_service = 
  Eliom_services.post_coservice ~fallback:main_service ~post_params:(string "name" ** string "password") ()

let create_account_form () =
  Eliom_output.Xhtml5.post_form ~service:create_account_service
    (fun (name1, name2) ->
      [p [pcdata "login: ";
          Eliom_output.Xhtml5.string_input ~input_type:`Text ~name:name1 ();
          br ();
          pcdata "password: ";
          Eliom_output.Xhtml5.string_input ~input_type:`Password ~name:name2 ();
          br ();
          Eliom_output.Xhtml5.string_input ~input_type:`Submit ~value:"Connect" ()
         ]]) ()

let _ =
  Eliom_output.Xhtml5.register
    ~service:new_user_form_service
    (fun () () ->
      Lwt.return
        (html (head (title (pcdata "")) [])
              (body [h1 [pcdata "Create an account"];
                     create_account_form ();
                    ])));

  Eliom_output.Action.register
    ~service:create_account_service
    (fun () (name, pwd) ->
      users := (name, pwd)::!users;
      Lwt.return ())
>>

    Then add the link to this service in the connection box:
<<code language="ocaml"|let connection_box () =
  Eliom_references.get username ~>>= fun u ->
  Lwt.return
    (match u with
      | Some s -> div [p [pcdata "You are connected as "; pcdata s; ];
                       disconnect_box () ]
      | None ->
        div [Eliom_output.Xhtml5.post_form ~service:connection_service
                (fun (name1, name2) ->
...
                ) ();
             p [Eliom_output.Xhtml5.a new_user_form_service [pcdata "Create an account"] ()]]
            )
>>

<<div class="encadre"|====Attached coservice====
Here I want to return to the main page after account creation.
I'm using an //attached coservice//, that is, a service that is identified
by both the path in the URL and a special coservice number (or name).
A form to such a service will change the path and send parameters
together with the coservce identifier (added automatically in an hidden
field).

In this precise case, I could have used a regular service,
as we do not really need the coservice identifier, but in many
cases, you may want to distinguish between several services
registered at the same path (with same parameters).
That's what attached coservices are made for.
>>

===Registration form with confirmation===
<<div class="concepts"|Dynamic registration of services\\
Session services>>

Now we want to add a confirmation page before actually creating the account.
We //replace// the service {{{create_account_service}}} by a new
POST attached coservice called {{{account_confirmation_service}}}:

<<code language="ocaml"|let account_confirmation_service =
  Eliom_services.post_coservice ~fallback:new_user_form_service ~post_params:(string "name" ** string "password") ()
>>
and we make the account creation form point at this new service.

We register on this service an HTML handler with the confirmation page.
As side effect, this page will create the actual account creation service:
<<code language="ocaml"|  Eliom_output.Xhtml5.register
    ~service:account_confirmation_service
    (fun () (name, pwd) ->
      let create_account_service =
        Eliom_output.Action.register_coservice
          ~fallback:main_service
          ~get_params:Eliom_parameters.unit
          ~timeout:60.
          (fun () () ->
            users := (name, pwd)::!users;
            Lwt.return ())
      in
      Lwt.return
        (html (head (title (pcdata "")) [])
              (body [h1 [pcdata "Confirm account creation for "; pcdata name];
                     p [Eliom_output.Xhtml5.a ~service:create_account_service [pcdata "Yes"] ();
                        pcdata " ";
                        Eliom_output.Xhtml5.a ~service:main_service [pcdata "No"] ()]
                    ])))
>>

Also remove the registration of the {{{create_account_service}}} 
service and modify the user creation form to make it points towards
{{{account_confirmation_service}}}.

<<div class="encadre"|====Dynamic creation of services====
In this example, we are dynamically creating a new service
(here a coservice that does an action).
This is done by the same {{{register}}} function as usual.

Dynamic creation of new services allows to create services
that depend on previous interaction with the user.
Here the {{{create_account_service}}} service depends on
{{{name}}} and {{{pwd}}}, that were send before by a form.

In this simple example, an alternative would have been to send
{{{name}}} and {{{pwd}}} again to the same service as in the
"basic registration form" example. But this solution is not possible
when you have too much data.

//Saving {{{name}}} and {{{pwd}}} as session data in a wrong solution!//
If the user duplicates his browser window and fill the user creation
form in both, then the confirmation link must create the right account!

A working alternative would have been to generate yourself a random key,
and save {{{name}}} and {{{pwd}}} in front of that key on a table you
have created on server side. This is the way such kind of Web interaction
is usually implemented. But Eliom's solution is much simpler!

The ability to register dynamically new services is strangely
implemented in very few Web frameworks, although it simplifies a lot
the programmation of that kind of Web interaction.
This feature is a variant of what is called
//continuation based Web programming//.
Think about it when you want to //create a page that depend on previous
interaction with the user//. Dynamic registration of services will automatically
record the "history" of the interaction, and make possible to use the
"back button" or to have several tabs on the same site.

Examples of uses:
* displaying the results of a search
* programming a "several step form" (when a form points at another one,
etc., like our registration form with confirmation).

On the contrary, if you want to implement a //shopping basket//,
you want it to be shared between all tabs of your Web site.
To do that, you will use session data.

//Warning:// Services are kept in memory. To avoid memory leaks,
you probably want to
put a timeout on your dynamic coservices. Just add the optional parameter
{{{?timeout}}} to the service creation function.
>>

<<div class="encadre"|====Session services====
Eliom also make possible to restrict the scope of services to
a session, a group of session, or even a client side process
(if you have a client side program running).
It works exactly like the scope of Eliom references.
To do that, just add the optional parameter
{{{~scope}}} to the registration function.
By default, the value is {{{`Global}}} (visible for everyone).
Other possible values: {{{`Session}}}, {{{`Session_group}}},
or {{{`Client_process}}}.

It is possible to register again for a session, tab or group,
services that have already been registered with public (site) visibility.
In such cases, Eliom will try first tab services, then session services,
then group services, and finally site services.
This makes possible to register specialized versions of a service
for one user, for example when she logs in.
>>

==A few enhancements==
===Displaying a "wrong password" message===
<<div class="concepts"|>>

In the current version, our Web site fails silently when the
password is wrong.
We now want to display an error message.
To do that, we need to pass information to the service occurring
after the action.
We record this information in
an Eliom reference with scope {{{`Request}}}.

Define an Eliom reference:
<<code language="ocaml"|let wrong_pwd = Eliom_references.eref ~scope:`Request false>>

Modify the connection box this way:
<<code language="ocaml"|let connection_box () =
  Eliom_references.get username ~>>= fun u ->
  Eliom_references.get wrong_pwd ~>>= fun wp ->
  Lwt.return
    (match u with
      | Some s -> div [p [pcdata "You are connected as "; pcdata s; ];
                       disconnect_box () ]
      | None ->
        let l =
          [Eliom_output.Xhtml5.post_form ~service:connection_service
            (fun (name1, name2) ->
              [p [pcdata "login: ";
                  Eliom_output.Xhtml5.string_input ~input_type:`Text ~name:name1 ();
                  br ();
                  pcdata "password: ";
                  Eliom_output.Xhtml5.string_input ~input_type:`Password ~name:name2 ();
                  br ();
                  Eliom_output.Xhtml5.string_input ~input_type:`Submit ~value:"Connect" ()
                 ]]) ();
             p [Eliom_output.Xhtml5.a new_user_form_service [pcdata "Create an account"] ()]]
        in
        if wp
        then div ((p [em [pcdata "Wrong user or password"]])::l)
        else div l
    )
>>

And modify the {{{connection_service}}} handler:
<<code language="ocaml"|  Eliom_output.Action.register
    ~service:connection_service
    (fun () (name, password) ->
      if check_pwd name password
      then Eliom_references.set username (Some name)
      else Eliom_references.set wrong_pwd true ~>>= fun () -> Lwt.return ());
>>





===Sending 404 errors for non-existing users===
<<div class="concepts"|Sending 404\\{{{Eliom_output.Any}}}>>

Our service {{{user_service}}} answers with any parameter, even if
the user does not exist in the database.
We want to check that the user is in the database before
displaying the page, and send a 404 error if not.
To do that, we will replace the module
<<ocsigendoc version="dev" file="Eliom_output.Eliom_appl.html"|<<span class="code"|Eliom_output.Xhtml5>>>> by
<<ocsigendoc version="dev" file="Eliom_output.Eliom_appl.html"|<<span class="code"|Eliom_output.Any>>>>
to register the service {{{user_service}}}:

<<code language="ocaml"|  Eliom_output.Any.register
    ~service:user_service
    (fun name () ->
      if List.exists (fun (n, _) -> n = name) !users
      then begin
        connection_box () ~>>= fun cf ->
        Eliom_output.Xhtml5.send
          (html (head (title (pcdata name)) [])
             (body [h1 [pcdata name];
                    cf;
                    p [Eliom_output.Xhtml5.a ~service:main_service [pcdata "Home"] ()]]))
      end
      else
        Eliom_output.Xhtml5.send
          ~code:404
          (html (head (title (pcdata "404")) [])
             (body [h1 [pcdata "404"];
                    p [pcdata "That page does not exist"]]))
    );
>>

<<div class="encadre"|===={{{Eliom_output.Any}}}====
The module <<ocsigendoc version="dev" file="Eliom_output.Eliom_appl.html"|<<span class="code"|Eliom_output.Any>>>>
can be used to create service that decide themselve the kind of output they want
to send.

Use the {{{send}}} function from the module you want to send the output.
That function also allows for example to specify the HTTP code (here 404)
or to set HTTP headers.
>>

<<div class="wip"|In the future, we may add functions likes {{{set_http_code}}}
or {{{set_http_header}}} to personalize the answer without using
{{{Eliom_output.Any}}}.
>>


The full code of our program can be downloaded [[/manual/dev/tuto.ml|here]].
